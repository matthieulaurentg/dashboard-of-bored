<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Console</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üê±</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        .terminal {
            width: 100%;
            height: calc(100vh - 140px);
            background: #000000;
            padding: 15px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .terminal::-webkit-scrollbar {
            width: 8px;
        }
        
        .terminal::-webkit-scrollbar-track {
            background: #000000;
        }
        
        .terminal::-webkit-scrollbar-thumb {
            background: #ffffff;
        }
        
        @media (max-width: 768px) {
            .terminal::-webkit-scrollbar {
                display: none;
            }
        }
        
        .input-section {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            background: #000000;
            padding: 10px 20px;
            border-top: 1px solid #ffffff;
        }
        
        .input-prompt {
            color: #ffffff;
            margin-right: 10px;
        }
        
        .input {
            flex: 1;
            background: #000000;
            color: #ffffff;
            border: none;
            outline: none;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            padding: 8px;
        }
        
        .mobile-buttons {
            display: none;
            position: fixed;
            bottom: 60px;
            left: 0;
            right: 0;
            background: #111;
            padding: 10px;
            border-top: 1px solid #333;
            overflow-x: auto;
            white-space: nowrap;
        }
        
        .mobile-btn {
            display: inline-block;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 8px 12px;
            margin: 2px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            min-width: 60px;
            text-align: center;
        }
        
        .mobile-btn:active {
            background: #555;
        }
        
        @media (max-width: 768px) {
            .terminal {
                height: calc(100vh - 60px);
                padding: 10px;
                font-size: 13px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .input-section {
                padding: 8px 10px;
            }
            
            .input {
                font-size: 16px;
                padding: 10px;
                border: 1px solid #333;
            }
            
            .mobile-buttons {
                display: none;
            }
        }
        
        @media (max-width: 480px) {
            .terminal {
                height: calc(100vh - 60px);
                padding: 8px;
                font-size: 12px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .input {
                font-size: 16px;
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="terminal" id="terminal">
MATTHIEU'S TEXT CONSOLE v1.0
Initializing...
System ready.
Available games: Three Card Roulette, Adventure, Stonks
Type "help" for commands

ROULETTE GAME ACTIVE
Current credits: $100

    </div>
    
    <div class="mobile-buttons" id="mobileButtons">
        <button class="mobile-btn" onclick="quickCommand('help')">help</button>
        <button class="mobile-btn" onclick="quickCommand('balance')">balance</button>
        <button class="mobile-btn" onclick="quickCommand('stats')">stats</button>
        <button class="mobile-btn" onclick="quickCommand('bet red 10')">bet red</button>
        <button class="mobile-btn" onclick="quickCommand('bet black 10')">bet black</button>
        <button class="mobile-btn" onclick="quickCommand('look')">look</button>
        <button class="mobile-btn" onclick="quickCommand('inventory')">inv</button>
        <button class="mobile-btn" onclick="quickCommand('adventure')">adventure</button>
        <button class="mobile-btn" onclick="quickCommand('roulette')">roulette</button>
        <button class="mobile-btn" onclick="quickCommand('stonks')">stonks</button>
        <button class="mobile-btn" onclick="quickCommand('clear')">clear</button>
    </div>
    
    <div class="input-section">
        <span class="input-prompt">></span>
        <input type="text" class="input" id="commandInput" autofocus>
    </div>

    <script>
        let currentGame = 'roulette';
        
        let rouletteState = {
            balance: 100,
            totalBets: 0,
            totalWins: 0,
            totalLosses: 0,
            lastCard: null,
            lastResult: null
        };
        
        let adventureState = {
            location: 'start',
            inventory: [],
            health: 100,
            score: 0,
            visitedLocations: [],
            gameFlags: {},
            activeQuests: []
        };
        
        let stonksState = {
            cash: 1000,
            portfolio: {
                TSLA: 0,
                APPL: 0,
                GOOG: 0,
                MSFT: 0,
                AMZN: 0
            },
            prices: {
                TSLA: 250,
                APPL: 180,
                GOOG: 140,
                MSFT: 320,
                AMZN: 130
            },
            priceHistory: {},
            totalTrades: 0,
            totalProfit: 0
        };

        const terminal = document.getElementById('terminal');
        const commandInput = document.getElementById('commandInput');
        
        let commandHistory = [];
        let historyIndex = -1;
        
        function quickCommand(cmd) {
            commandInput.value = cmd;
            processCommand();
        }
        
        // Auto-save functionality
        function saveGame() {
            const gameData = {
                currentGame: currentGame,
                rouletteState: rouletteState,
                adventureState: adventureState,
                stonksState: stonksState,
                timestamp: Date.now()
            };
            localStorage.setItem('matthieu_console_save', JSON.stringify(gameData));
        }
        
        function loadGame() {
            const saved = localStorage.getItem('matthieu_console_save');
            if (saved) {
                try {
                    const gameData = JSON.parse(saved);
                    currentGame = gameData.currentGame || 'roulette';
                    rouletteState = { ...rouletteState, ...gameData.rouletteState };
                    adventureState = { ...adventureState, ...gameData.adventureState };
                    stonksState = { ...stonksState, ...gameData.stonksState };
                    print('Game loaded from auto-save.');
                } catch (e) {
                    print('Save file corrupted. Starting fresh.');
                }
            }
        }
        
        // Auto-save every 10 seconds
        setInterval(saveGame, 10000);
        
        // Real-time stock price updates every 15 seconds
        setInterval(() => {
            if (currentGame === 'stonks') {
                updateMarketPrices();
            }
        }, 15000);
        
        // Adventure Game - Massive World with 1000+ Locations
        const gameWorld = {};
        
        // Massive location database - 1000+ unique areas
        function generateMassiveWorld() {
            const biomes = ['forest', 'mountain', 'desert', 'swamp', 'plains', 'coast', 'ruins', 'cave', 'village', 'castle'];
            const adjectives = ['ancient', 'dark', 'mysterious', 'haunted', 'peaceful', 'dangerous', 'hidden', 'frozen', 'burning', 'crystal', 'golden', 'silver', 'emerald', 'shadow', 'bright', 'misty', 'windy', 'quiet', 'noisy', 'sacred'];
            const descriptors = ['grove', 'peak', 'valley', 'river', 'lake', 'bridge', 'tower', 'gate', 'path', 'clearing', 'ruins', 'temple', 'mine', 'camp', 'fort', 'garden', 'marsh', 'cliff', 'cavern', 'tunnel'];
            
            const itemPool = [
                'ancient_key', 'magic_scroll', 'healing_herb', 'silver_coin', 'rusty_sword', 'glowing_gem', 
                'old_map', 'rope', 'lantern', 'mysterious_amulet', 'iron_shield', 'spell_book', 
                'health_potion', 'golden_ring', 'crystal_shard', 'enchanted_bow', 'dragon_scale',
                'phoenix_feather', 'moonstone', 'star_fragment', 'blessed_water', 'ancient_tome',
                'magic_wand', 'elven_cloak', 'dwarven_hammer', 'giant_pearl', 'cursed_skull',
                'holy_symbol', 'demon_horn', 'angel_wing', 'time_crystal', 'void_essence'
            ];
            
            for (let i = 0; i < 1200; i++) {
                const biome = biomes[i % biomes.length];
                const adj = adjectives[Math.floor(i / 3) % adjectives.length];
                const desc = descriptors[Math.floor(i / 7) % descriptors.length];
                
                const locationId = `loc_${i}`;
                const name = `${adj.charAt(0).toUpperCase() + adj.slice(1)} ${biome.charAt(0).toUpperCase() + biome.slice(1)} ${desc.charAt(0).toUpperCase() + desc.slice(1)}`;
                
                // Generate unique descriptions
                const descriptions = {
                    forest: ['Ancient trees tower overhead, their massive trunks disappearing into misty heights.', 'Dappled sunlight filters through the canopy, creating patterns of light and shadow.', 'The forest floor is carpeted with fallen leaves that crunch beneath your feet.'],
                    mountain: ['Rocky peaks stretch endlessly toward the sky, their summits lost in clouds.', 'The thin air makes breathing difficult as you navigate the treacherous paths.', 'Snow and ice glisten on the higher elevations, reflecting the sunlight.'],
                    desert: ['Endless dunes of golden sand stretch to the horizon in every direction.', 'The scorching sun beats down mercilessly on the barren landscape.', 'Ancient ruins peek through the shifting sands, weathered by countless storms.'],
                    swamp: ['Murky water reflects twisted trees draped in hanging moss.', 'Strange sounds echo through the humid air as unseen creatures move nearby.', 'The ground squelches beneath your feet with every step.'],
                    plains: ['Rolling grasslands extend as far as the eye can see.', 'Wildflowers dot the landscape in brilliant patches of color.', 'A gentle breeze causes the grass to wave like an ocean of green.'],
                    coast: ['Waves crash against the rocky shoreline, sending spray high into the air.', 'Seagulls cry overhead as they dive for fish in the churning waters.', 'Salt air fills your lungs with each breath.'],
                    ruins: ['Crumbling stone structures hint at a once-great civilization.', 'Vines and vegetation have reclaimed much of the ancient architecture.', 'Strange symbols are carved into weathered walls and fallen pillars.'],
                    cave: ['Stalactites hang like teeth from the cavern ceiling above.', 'Your footsteps echo endlessly in the dark tunnels.', 'Strange formations of rock create an alien landscape underground.'],
                    village: ['Small houses with smoking chimneys line cobblestone streets.', 'Villagers go about their daily routines, nodding politely as you pass.', 'Market stalls offer various goods and the aroma of fresh bread fills the air.'],
                    castle: ['Massive stone walls rise imposingly against the sky.', 'Banners flutter from tall towers in the mountain breeze.', 'Guards patrol the battlements, keeping watch for threats.']
                };
                
                const desc_options = descriptions[biome] || ['A mysterious location that defies easy description.'];
                const description = desc_options[i % desc_options.length];
                
                // Random items (20% chance)
                const items = [];
                if ((i * 17) % 100 < 20) {
                    items.push(itemPool[(i * 23) % itemPool.length]);
                }
                
                // Generate truly random exits (2-5 exits per location)
                const directions = ['north', 'south', 'east', 'west', 'northeast', 'northwest', 'southeast', 'southwest', 'up', 'down'];
                const exits = {};
                const numExits = 2 + (i % 4);
                
                for (let j = 0; j < numExits; j++) {
                    const direction = directions[(i + j * 7) % directions.length];
                    // Connect to different random locations
                    const targetId = `loc_${(i + (j + 1) * 37 + (i % 10) * 13) % 1200}`;
                    exits[direction] = targetId;
                }
                
                gameWorld[locationId] = {
                    name: name,
                    description: description,
                    exits: exits,
                    items: items,
                    firstVisit: `You discover ${name} for the first time.`,
                    hasQuest: (i * 11) % 100 < 15, // 15% chance of quest
                    questCompleted: false
                };
            }
            
            // Set starting location
            gameWorld['start'] = {
                name: 'Forest Entrance',
                description: 'You stand at the edge of a vast world full of adventure. Paths lead in multiple directions.',
                exits: { north: 'loc_1', east: 'loc_2', south: 'loc_3', west: 'loc_4' },
                items: ['map_fragment'],
                firstVisit: 'Your adventure begins here. The world awaits your exploration!',
                hasQuest: false,
                questCompleted: false
            };
        }
        
        // Quest system
        const questDatabase = [
            { id: 'find_crystal', name: 'Crystal Hunter', description: 'Find 3 crystal shards', reward: 'enchanted_bow', progress: 0, target: 3 },
            { id: 'explore_ruins', name: 'Ancient Explorer', description: 'Visit 5 different ruins', reward: 'ancient_tome', progress: 0, target: 5 },
            { id: 'collect_gems', name: 'Gem Collector', description: 'Collect 10 precious gems', reward: 'dragon_scale', progress: 0, target: 10 },
            { id: 'mountain_climber', name: 'Peak Seeker', description: 'Reach 3 mountain peaks', reward: 'phoenix_feather', progress: 0, target: 3 },
            { id: 'cave_explorer', name: 'Depths Walker', description: 'Explore 7 different caves', reward: 'void_essence', progress: 0, target: 7 }
        ];
        
        function getLocation(locationId) {
            return gameWorld[locationId] || null;
        }
        
        function showMap() {
            print('=== DISCOVERED LOCATIONS MAP ===');
            const visited = adventureState.visitedLocations;
            if (visited.length === 0) {
                print('No locations discovered yet.');
                return;
            }
            
            const locationsByType = {};
            visited.forEach(locId => {
                const loc = getLocation(locId);
                if (loc) {
                    const type = loc.name.split(' ')[1] || 'Unknown';
                    if (!locationsByType[type]) locationsByType[type] = [];
                    locationsByType[type].push(loc.name);
                }
            });
            
            Object.keys(locationsByType).forEach(type => {
                print(`${type.toUpperCase()}:`);
                locationsByType[type].forEach(name => {
                    print(`  - ${name}`);
                });
            });
            print(`Total locations discovered: ${visited.length}/1200`);
            print('');
        }

        function print(text) {
            const line = document.createElement('div');
            line.textContent = text;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function showHelp() {
            if (currentGame === 'roulette') {
                print('ROULETTE COMMANDS:');
                print('help - Show commands');
                print('balance - Show credits');
                print('stats - Show statistics');
                print('bet red [amount] - Bet on red');
                print('bet black [amount] - Bet on black');
                print('bet hearts [amount] - Bet on hearts');
                print('bet diamonds [amount] - Bet on diamonds');
                print('bet clubs [amount] - Bet on clubs');
                print('bet spades [amount] - Bet on spades');
                print('rules - Show rules');
                print('adventure - Switch to adventure');
                print('stonks - Switch to stonks');
                print('restart - Reset all games and start fresh');
                print('clear - Clear screen');
                print('');
            } else if (currentGame === 'adventure') {
                print('ADVENTURE COMMANDS:');
                print('help - Show commands');
                print('look - Look around');
                print('go [direction] - Move');
                print('take [item] - Take item');
                print('inventory - Show items');
                print('use [item] - Use item');
                print('talk - Talk to people');
                print('status - Show status');
                print('map - Show discovered locations');
                print('quests - Show active quests');
                print('roulette - Switch to roulette');
                print('stonks - Switch to stonks');
                print('restart - Reset all games and start fresh');
                print('clear - Clear screen');
                print('');
            } else if (currentGame === 'stonks') {
                print('STONKS COMMANDS:');
                print('help - Show commands');
                print('portfolio - Show holdings');
                print('prices - Show current prices');
                print('buy [stock] [shares] - Buy shares');
                print('sell [stock] [shares] - Sell shares');
                print('market - Update market prices');
                print('stats - Show trading stats');
                print('roulette - Switch to roulette');
                print('adventure - Switch to adventure');
                print('restart - Reset all games and start fresh');
                print('clear - Clear screen');
                print('');
            }
        }
        
        function describeLocation() {
            const loc = getLocation(adventureState.location);
            if (!loc) {
                print('ERROR: Location not found!');
                adventureState.location = 'start';
                return;
            }
            
            print('=== ' + loc.name.toUpperCase() + ' ===');
            
            if (!adventureState.visitedLocations.includes(adventureState.location)) {
                print(loc.firstVisit);
                adventureState.visitedLocations.push(adventureState.location);
                adventureState.score += 10;
            }
            
            print(loc.description);
            
            if (loc.hasQuest && !loc.questCompleted) {
                print('üéØ QUEST AVAILABLE: Talk to someone here!');
            }
            
            if (loc.items && loc.items.length > 0) {
                print('Items: ' + loc.items.join(', '));
            }
            
            const exitList = Object.keys(loc.exits);
            if (exitList.length > 0) {
                print('Exits: ' + exitList.join(', '));
            }
            print('');
        }
        
        function movePlayer(direction) {
            const loc = getLocation(adventureState.location);
            if (!loc) {
                print('ERROR: Current location not found!');
                return;
            }
            
            if (loc.exits[direction]) {
                adventureState.location = loc.exits[direction];
                print('Moving...');
                describeLocation();
            } else {
                print('Cannot go that way.');
            }
        }
        
        function takeItem(item) {
            const loc = getLocation(adventureState.location);
            if (!loc || !loc.items) {
                print('Item not found.');
                return;
            }
            
            const itemIndex = loc.items.indexOf(item);
            if (itemIndex !== -1) {
                loc.items.splice(itemIndex, 1);
                adventureState.inventory.push(item);
                adventureState.score += 5;
                print('Taken: ' + item);
                saveGame();
            } else {
                print('Item not found.');
            }
        }
        
        function showInventory() {
            if (adventureState.inventory.length === 0) {
                print('Inventory empty.');
            } else {
                print('Inventory: ' + adventureState.inventory.join(', '));
            }
        }
        
        function useItem(item) {
            if (!adventureState.inventory.includes(item)) {
                print('Item not in inventory.');
                return;
            }
            
            switch(item) {
                case 'potion':
                    adventureState.health = Math.min(100, adventureState.health + 25);
                    adventureState.inventory = adventureState.inventory.filter(i => i !== item);
                    adventureState.score += 15;
                    print('Health restored to: ' + adventureState.health);
                    break;
                case 'crystal':
                    if (adventureState.location === 'village_center') {
                        print('Wizard examines crystal...');
                        print('"This crystal has great power," he says.');
                        adventureState.inventory.push('magic_ring');
                        adventureState.inventory = adventureState.inventory.filter(i => i !== item);
                        adventureState.score += 50;
                        print('Received: magic_ring');
                    } else {
                        print('Crystal glows but nothing happens.');
                    }
                    break;
                case 'stick':
                    print('You wave the stick. Could be useful as weapon.');
                    break;
                case 'coin':
                    if (adventureState.location === 'shop') {
                        print('Trading with shopkeeper...');
                        adventureState.inventory.push('super_potion');
                        adventureState.inventory = adventureState.inventory.filter(i => i !== item);
                        adventureState.score += 25;
                        print('Received: super_potion');
                    } else {
                        print('Coin gleams in the light.');
                    }
                    break;
                default:
                    print('Cannot use that here.');
            }
        }
        
        function talkToCharacters() {
            const loc = getLocation(adventureState.location);
            if (!loc) {
                print('No one to talk to.');
                return;
            }
            
            if (loc.hasQuest && !loc.questCompleted) {
                // Give quest
                const questIndex = adventureState.location.charCodeAt(0) % questDatabase.length;
                const quest = questDatabase[questIndex];
                if (!adventureState.activeQuests) adventureState.activeQuests = [];
                
                if (!adventureState.activeQuests.find(q => q.id === quest.id)) {
                    adventureState.activeQuests.push({...quest});
                    print(`Quest Giver: "I have a task for you!"`);
                    print(`üéØ NEW QUEST: ${quest.name}`);
                    print(`   ${quest.description}`);
                    print(`   Reward: ${quest.reward}`);
                    loc.questCompleted = true;
                } else {
                    print('Quest Giver: "You already have this quest!"');
                }
            } else {
                // Random NPC dialogue
                const npcDialogue = [
                    'Traveler: "The path ahead is treacherous, be careful."',
                    'Merchant: "I have rare goods if you have coin."',
                    'Hermit: "Few venture to these parts anymore."',
                    'Guard: "State your business here."',
                    'Local: "You\'re not from around here, are you?"',
                    'Adventurer: "I\'ve seen many wonders in my travels."',
                    'Scholar: "These ruins hold ancient secrets."',
                    'Ranger: "The wildlife here is quite unique."'
                ];
                
                const seed = adventureState.location.charCodeAt(0) % npcDialogue.length;
                if ((seed * 3) % 10 < 6) { // 60% chance of NPC
                    print(npcDialogue[seed]);
                } else {
                    print('No one to talk to.');
                }
            }
        }
        
        function showAdventureStatus() {
            const loc = getLocation(adventureState.location);
            print('STATUS:');
            print('Health: ' + adventureState.health + '/100');
            print('Score: ' + adventureState.score);
            print('Location: ' + (loc ? loc.name : 'Unknown'));
            print('Inventory: ' + (adventureState.inventory.length > 0 ? adventureState.inventory.join(', ') : 'Empty'));
            print('Locations discovered: ' + adventureState.visitedLocations.length + '/1200');
            
            if (adventureState.activeQuests && adventureState.activeQuests.length > 0) {
                print('Active Quests:');
                adventureState.activeQuests.forEach(quest => {
                    print(`  - ${quest.name}: ${quest.progress}/${quest.target}`);
                });
            }
            print('');
        }

        function showBalance() {
            print('Balance: $' + rouletteState.balance);
            print('');
        }

        function showStats() {
            print('STATISTICS:');
            print('Total Bets: ' + rouletteState.totalBets);
            print('Wins: ' + rouletteState.totalWins);
            print('Losses: ' + rouletteState.totalLosses);
            const winRate = rouletteState.totalBets > 0 ? ((rouletteState.totalWins / rouletteState.totalBets) * 100).toFixed(1) : 0;
            print('Win Rate: ' + winRate + '%');
            if (rouletteState.lastCard) {
                print('Last Card: ' + rouletteState.lastCard);
                print('Last Result: ' + rouletteState.lastResult);
            }
            print('');
        }

        function showRules() {
            print('RULES:');
            print('Cards: Hearts, Diamonds, Clubs, Spades, Joker');
            print('Color Bets (2:1): red, black');
            print('Suit Bets (3:1): hearts, diamonds, clubs, spades');
            print('Joker: Credits refunded');
            print('Minimum bet: $1');
            print('');
        }

        function processBet(betType, amount) {
            if (amount < 1) {
                print('Minimum bet: $1');
                return;
            }
            
            if (amount > rouletteState.balance) {
                print('Insufficient credits: $' + rouletteState.balance);
                return;
            }

            rouletteState.balance -= amount;
            rouletteState.totalBets++;

            const cards = ['hearts', 'diamonds', 'clubs', 'spades', 'joker'];
            const drawnCard = cards[Math.floor(Math.random() * cards.length)];
            rouletteState.lastCard = drawnCard;

            print('Bet: ' + betType + ' $' + amount);
            print('Drawing...');
            print('Card: ' + drawnCard.toUpperCase());

            if (drawnCard === 'joker') {
                rouletteState.balance += amount;
                rouletteState.lastResult = 'refund';
                print('JOKER! Credits refunded.');
            } else {
                let won = false;
                let payout = 0;

                if (betType === 'red' && (drawnCard === 'hearts' || drawnCard === 'diamonds')) {
                    won = true;
                    payout = amount * 2;
                } else if (betType === 'black' && (drawnCard === 'clubs' || drawnCard === 'spades')) {
                    won = true;
                    payout = amount * 2;
                } else if (betType === drawnCard) {
                    won = true;
                    payout = amount * 3;
                }

                if (won) {
                    rouletteState.balance += payout;
                    rouletteState.totalWins++;
                    rouletteState.lastResult = 'win $' + payout;
                    print('WIN! Payout: $' + payout);
                } else {
                    rouletteState.totalLosses++;
                    rouletteState.lastResult = 'loss $' + amount;
                    print('LOSE! Lost: $' + amount);
                }
            }

            print('Balance: $' + rouletteState.balance);

            if (rouletteState.balance <= 0) {
                print('Out of credits! Reset to $100');
                rouletteState.balance = 100;
            }
            print('');
            saveGame(); // Auto-save after bet
        }

        function switchToAdventure() {
            currentGame = 'adventure';
            print('Switching to Adventure...');
            print('');
            describeLocation();
            saveGame(); // Auto-save on game switch
        }
        
        function switchToRoulette() {
            currentGame = 'roulette';
            print('Switching to Roulette...');
            print('Credits: $' + rouletteState.balance);
            print('');
            saveGame(); // Auto-save on game switch
        }
        
        function switchToStonks() {
            currentGame = 'stonks';
            print('Switching to Stonks Trading...');
            print('Cash: $' + stonksState.cash);
            showPortfolioValue();
            print('');
            saveGame(); // Auto-save on game switch
        }
        
        function restartAllGames() {
            print('Are you sure you want to restart? This will reset ALL progress!');
            print('Type "confirm restart" to proceed or any other command to cancel.');
            
            // Set a flag to wait for confirmation
            adventureState.awaitingRestart = true;
        }
        
        function confirmRestart() {
            // Reset all game states to defaults
            currentGame = 'roulette';
            
            rouletteState = {
                balance: 100,
                totalBets: 0,
                totalWins: 0,
                totalLosses: 0,
                lastCard: null,
                lastResult: null
            };
            
            adventureState = {
                location: 'start',
                inventory: [],
                health: 100,
                score: 0,
                visitedLocations: [],
                gameFlags: {},
                activeQuests: [],
                awaitingRestart: false
            };
            
            stonksState = {
                cash: 1000,
                portfolio: {
                    TSLA: 0,
                    APPL: 0,
                    GOOG: 0,
                    MSFT: 0,
                    AMZN: 0
                },
                prices: {
                    TSLA: 250,
                    APPL: 180,
                    GOOG: 140,
                    MSFT: 320,
                    AMZN: 130
                },
                priceHistory: {},
                totalTrades: 0,
                totalProfit: 0
            };
            
            commandHistory = [];
            historyIndex = -1;
            
            // Clear localStorage
            localStorage.removeItem('matthieu_console_save');
            
            // Clear terminal
            terminal.innerHTML = '';
            
            print('üîÑ GAME RESTARTED SUCCESSFULLY!');
            print('All progress has been reset.');
            print('ROULETTE GAME ACTIVE');
            print('Current credits: $100');
            print('Type "help" for commands.');
            print('');
            
            saveGame();
        }
        
        function updateMarketPrices() {
            const stocks = Object.keys(stonksState.prices);
            stocks.forEach(stock => {
                const change = (Math.random() - 0.5) * 20; // -10 to +10
                const newPrice = Math.max(10, stonksState.prices[stock] + change);
                stonksState.prices[stock] = Math.round(newPrice * 100) / 100;
            });
        }
        
        function showPrices() {
            print('CURRENT STOCK PRICES:');
            Object.entries(stonksState.prices).forEach(([stock, price]) => {
                print(stock + ': $' + price.toFixed(2));
            });
            print('');
        }
        
        function showPortfolio() {
            print('PORTFOLIO:');
            print('Cash: $' + stonksState.cash.toFixed(2));
            let totalValue = stonksState.cash;
            Object.entries(stonksState.portfolio).forEach(([stock, shares]) => {
                if (shares > 0) {
                    const value = shares * stonksState.prices[stock];
                    totalValue += value;
                    print(stock + ': ' + shares + ' shares ($' + value.toFixed(2) + ')');
                }
            });
            print('Total Portfolio Value: $' + totalValue.toFixed(2));
            print('');
        }
        
        function showPortfolioValue() {
            let totalValue = stonksState.cash;
            Object.entries(stonksState.portfolio).forEach(([stock, shares]) => {
                totalValue += shares * stonksState.prices[stock];
            });
            print('Portfolio Value: $' + totalValue.toFixed(2));
        }
        
        function showStonksStats() {
            print('TRADING STATISTICS:');
            print('Total Trades: ' + stonksState.totalTrades);
            print('Total Profit/Loss: $' + stonksState.totalProfit.toFixed(2));
            print('');
        }
        
        function buyStonks(stock, shares) {
            stock = stock.toUpperCase();
            if (!stonksState.prices[stock]) {
                print('Unknown stock: ' + stock);
                print('Available: TSLA, APPL, GOOG, MSFT, AMZN');
                return;
            }
            
            const cost = shares * stonksState.prices[stock];
            if (cost > stonksState.cash) {
                print('Insufficient cash. Need $' + cost.toFixed(2) + ', have $' + stonksState.cash.toFixed(2));
                return;
            }
            
            stonksState.cash -= cost;
            stonksState.portfolio[stock] += shares;
            stonksState.totalTrades++;
            
            print('Bought ' + shares + ' shares of ' + stock + ' for $' + cost.toFixed(2));
            print('Cash remaining: $' + stonksState.cash.toFixed(2));
            saveGame();
        }
        
        function sellStonks(stock, shares) {
            stock = stock.toUpperCase();
            if (!stonksState.prices[stock]) {
                print('Unknown stock: ' + stock);
                return;
            }
            
            if (stonksState.portfolio[stock] < shares) {
                print('Insufficient shares. Have ' + stonksState.portfolio[stock] + ' shares of ' + stock);
                return;
            }
            
            const revenue = shares * stonksState.prices[stock];
            stonksState.cash += revenue;
            stonksState.portfolio[stock] -= shares;
            stonksState.totalTrades++;
            stonksState.totalProfit += revenue - (shares * 100); // Assume avg buy price of 100 for profit calc
            
            print('Sold ' + shares + ' shares of ' + stock + ' for $' + revenue.toFixed(2));
            print('Cash: $' + stonksState.cash.toFixed(2));
            saveGame();
        }

        function processCommand() {
            const command = commandInput.value.trim().toLowerCase();
            if (!command) return;

            // Check for restart confirmation
            if (adventureState.awaitingRestart) {
                if (command === 'confirm restart') {
                    confirmRestart();
                    return;
                } else {
                    print('> ' + command);
                    print('Restart cancelled.');
                    adventureState.awaitingRestart = false;
                    commandInput.value = '';
                    return;
                }
            }

            // Add to command history
            if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command) {
                commandHistory.push(command);
                if (commandHistory.length > 50) { // Keep last 50 commands
                    commandHistory.shift();
                }
            }
            historyIndex = -1;

            print('> ' + command);
            commandInput.value = '';

            const parts = command.split(' ');
            const cmd = parts[0];

            if (cmd === 'help') {
                showHelp();
                return;
            }
            if (cmd === 'clear') {
                terminal.innerHTML = '';
                return;
            }
            if (cmd === 'adventure') {
                switchToAdventure();
                return;
            }
            if (cmd === 'roulette') {
                switchToRoulette();
                return;
            }
            if (cmd === 'stonks') {
                switchToStonks();
                return;
            }
            if (cmd === 'restart') {
                restartAllGames();
                return;
            }

            if (currentGame === 'roulette') {
                switch (cmd) {
                    case 'balance':
                        showBalance();
                        break;
                    case 'stats':
                        showStats();
                        break;
                    case 'rules':
                        showRules();
                        break;
                    case 'bet':
                        if (parts.length < 3) {
                            print('Usage: bet [type] [amount]');
                            break;
                        }
                        const betType = parts[1];
                        const amount = parseInt(parts[2]);
                        
                        if (isNaN(amount)) {
                            print('Invalid amount');
                            break;
                        }

                        const validBets = ['red', 'black', 'hearts', 'diamonds', 'clubs', 'spades'];
                        if (!validBets.includes(betType)) {
                            print('Invalid bet. Valid: red, black, hearts, diamonds, clubs, spades');
                            break;
                        }

                        processBet(betType, amount);
                        break;
                    default:
                        print('Unknown command. Type "help"');
                        break;
                }
            } else if (currentGame === 'adventure') {
                switch (cmd) {
                    case 'look':
                        describeLocation();
                        break;
                    case 'go':
                        if (parts.length < 2) {
                            print('Go where? (north, south, east, west, inside, outside)');
                        } else {
                            movePlayer(parts[1]);
                        }
                        break;
                    case 'take':
                        if (parts.length < 2) {
                            print('Take what?');
                        } else {
                            takeItem(parts[1]);
                        }
                        break;
                    case 'inventory':
                        showInventory();
                        break;
                    case 'use':
                        if (parts.length < 2) {
                            print('Use what?');
                        } else {
                            useItem(parts[1]);
                        }
                        break;
                    case 'talk':
                        talkToCharacters();
                        break;
                    case 'status':
                        showAdventureStatus();
                        break;
                    case 'map':
                        showMap();
                        break;
                    case 'quests':
                        if (adventureState.activeQuests && adventureState.activeQuests.length > 0) {
                            print('ACTIVE QUESTS:');
                            adventureState.activeQuests.forEach(quest => {
                                print(`üéØ ${quest.name}: ${quest.progress}/${quest.target}`);
                                print(`   ${quest.description}`);
                                print(`   Reward: ${quest.reward}`);
                            });
                        } else {
                            print('No active quests. Talk to NPCs to find quests!');
                        }
                        print('');
                        break;
                    default:
                        print('Unknown command. Type "help"');
                        break;
                }
            } else if (currentGame === 'stonks') {
                switch (cmd) {
                    case 'portfolio':
                        showPortfolio();
                        break;
                    case 'prices':
                        showPrices();
                        break;
                    case 'market':
                        updateMarketPrices();
                        print('Market prices updated!');
                        showPrices();
                        break;
                    case 'stats':
                        showStonksStats();
                        break;
                    case 'buy':
                        if (parts.length < 3) {
                            print('Usage: buy [stock] [shares]');
                            print('Available stocks: TSLA, APPL, GOOG, MSFT, AMZN');
                            break;
                        }
                        const buyStock = parts[1];
                        const buyShares = parseInt(parts[2]);
                        
                        if (isNaN(buyShares) || buyShares <= 0) {
                            print('Invalid number of shares');
                            break;
                        }
                        
                        buyStonks(buyStock, buyShares);
                        break;
                    case 'sell':
                        if (parts.length < 3) {
                            print('Usage: sell [stock] [shares]');
                            break;
                        }
                        const sellStock = parts[1];
                        const sellShares = parseInt(parts[2]);
                        
                        if (isNaN(sellShares) || sellShares <= 0) {
                            print('Invalid number of shares');
                            break;
                        }
                        
                        sellStonks(sellStock, sellShares);
                        break;
                    default:
                        print('Unknown command. Type "help"');
                        break;
                }
            }
        }

        commandInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                processCommand();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0) {
                    if (historyIndex === -1) {
                        historyIndex = commandHistory.length - 1;
                    } else if (historyIndex > 0) {
                        historyIndex--;
                    }
                    commandInput.value = commandHistory[historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex !== -1) {
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        commandInput.value = commandHistory[historyIndex];
                    } else {
                        historyIndex = -1;
                        commandInput.value = '';
                    }
                }
            }
        });
        
        // Prevent zoom on mobile when focusing input
        commandInput.addEventListener('focus', function() {
            if (window.innerWidth <= 768) {
                document.querySelector('meta[name=viewport]').setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            }
        });
        
        commandInput.addEventListener('blur', function() {
            if (window.innerWidth <= 768) {
                document.querySelector('meta[name=viewport]').setAttribute('content', 'width=device-width, initial-scale=1.0');
            }
        });

        // Initialize the massive game world
        generateMassiveWorld();
        
        // Load game on startup
        loadGame();
        
        // Ensure input stays focused
        function keepFocus() {
            if (document.activeElement !== commandInput) {
                commandInput.focus();
            }
        }
        
        document.addEventListener('click', keepFocus);
        document.addEventListener('touchend', keepFocus);
        
        setTimeout(() => {
            print('Ready. Type "help" for commands.');
            print('üåç Massive world generated: 1200 unique locations to explore!');
            commandInput.focus();
            saveGame(); // Initial save
        }, 1000);
    </script>
</body>
</html>